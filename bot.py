# -*- coding: utf-8 -*-
import os
import json
import asyncio
import functools
import logging
import time
from datetime import datetime, time as dtime
import signal
import atexit

from aiogram import Bot, Dispatcher, types
from aiogram.types import ParseMode
from aiogram.utils import exceptions
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
from pytz import timezone
from dotenv import load_dotenv
from aiohttp import web

# === –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ===
load_dotenv()
TOKEN = os.getenv("TG_BOT_TOKEN", "YOUR_TOKEN_HERE")
CHAT_ID = int(os.getenv("TG_CHAT_ID", "-1002841862533"))
ADMIN_ID = int(os.getenv("TG_ADMIN_ID", "914344682"))
DATA_FILE = os.getenv("DATA_FILE", "bot_data.json")
PORT = int(os.getenv("PORT", 8080))
LOCK_FILE = "bot.lock"
LOG_FILE = "bot.log"

# === –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ ===
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler(LOG_FILE, encoding="utf-8"),
        logging.StreamHandler()
    ]
)
log = logging.getLogger("bot")

# === –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–∞ ===
if TOKEN == "YOUR_TOKEN_HERE" or not TOKEN:
    raise RuntimeError("‚ùå TG_BOT_TOKEN –Ω–µ –∑–∞–¥–∞–Ω –≤ .env! –£–∫–∞–∂–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ç–æ–∫–µ–Ω Telegram –±–æ—Ç–∞.")

# === –ó–∞—â–∏—Ç–∞ –æ—Ç –¥—É–±–ª–∏–∫–∞—Ç–æ–≤ ===
if os.path.exists(LOCK_FILE):
    log.warning("‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω lock-—Ñ–∞–π–ª. –í–æ–∑–º–æ–∂–Ω–æ, –±–æ—Ç —É–∂–µ –∑–∞–ø—É—â–µ–Ω.")
    # –∂–¥—ë–º 30 —Å–µ–∫—É–Ω–¥, –≤–¥—Ä—É–≥ –ø—Ä–µ–¥—ã–¥—É—â–∏–π –∏–Ω—Å—Ç–∞–Ω—Å –µ—â—ë –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è
    time.sleep(30)
    if os.path.exists(LOCK_FILE):
        raise RuntimeError("‚ùå –í—Ç–æ—Ä–æ–π —ç–∫–∑–µ–º–ø–ª—è—Ä –±–æ—Ç–∞ –∑–∞–ø—Ä–µ—â—ë–Ω (lock-—Ñ–∞–π–ª –Ω–∞–π–¥–µ–Ω).")

with open(LOCK_FILE, "w") as f:
    f.write(str(os.getpid()))
atexit.register(lambda: os.path.exists(LOCK_FILE) and os.remove(LOCK_FILE))

# === Telegram –∏ –æ–∫—Ä—É–∂–µ–Ω–∏–µ ===
bot = Bot(token=TOKEN, parse_mode=ParseMode.HTML)
dp = Dispatcher(bot)

kaliningrad_tz = timezone("Europe/Kaliningrad")
scheduler = AsyncIOScheduler(timezone=kaliningrad_tz)

active_polls = {}
stats = {}

# === –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –æ–ø—Ä–æ—Å–æ–≤ ===
polls_config = [
    {"day": "tue", "time_poll": "09:00", "time_game": "20:00",
     "question": "–°–µ–≥–æ–¥–Ω—è —Å–æ–±–∏—Ä–∞–µ–º—Å—è –Ω–∞ –ø–µ—Å—á–∞–Ω–∫–µ –≤ 20:00?",
     "options": ["–î–∞ ‚úÖ", "–ù–µ—Ç ‚ùå", "–ü–æ–¥ –≤–æ–ø—Ä–æ—Å–æ–º ‚ùî (–æ—Ç–≤–µ—á—É –ø–æ–∑–∂–µ)"]},
    {"day": "thu", "time_poll": "09:00", "time_game": "20:00",
     "question": "–°–µ–≥–æ–¥–Ω—è —Å–æ–±–∏—Ä–∞–µ–º—Å—è –Ω–∞ –ø–µ—Å—á–∞–Ω–∫–µ –≤ 20:00?",
     "options": ["–î–∞ ‚úÖ", "–ù–µ—Ç ‚ùå", "–ü–æ–¥ –≤–æ–ø—Ä–æ—Å–æ–º ‚ùî (–æ—Ç–≤–µ—á—É –ø–æ–∑–∂–µ)"]},
    {"day": "fri", "time_poll": "21:00", "time_game": "12:00",
     "question": "–ó–∞–≤—Ç—Ä–∞ –≤ 12:00 —Å–æ–±–∏—Ä–∞–µ–º—Å—è –Ω–∞ –ø–µ—Å—á–∞–Ω–∫–µ?",
     "options": ["–î–∞ ‚úÖ", "–ù–µ—Ç ‚ùå"]}
]

# === –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ / –∑–∞–≥—Ä—É–∑–∫–∞ ===
async def save_data():
    try:
        data = {"active_polls": active_polls, "stats": stats}
        def _write():
            with open(DATA_FILE, "w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        await asyncio.to_thread(_write)
        log.info("üíæ –î–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã.")
    except Exception as e:
        log.exception(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö: {e}")

async def load_data():
    global active_polls, stats
    try:
        if os.path.exists(DATA_FILE):
            def _read():
                with open(DATA_FILE, "r", encoding="utf-8") as f:
                    return json.load(f)
            data = await asyncio.to_thread(_read)
            active_polls = data.get("active_polls", {})
            stats = data.get("stats", {})
            log.info("‚úÖ –î–∞–Ω–Ω—ã–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –∏–∑ —Ñ–∞–π–ª–∞.")
        else:
            log.info("‚ÑπÔ∏è –ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö ‚Äî —Å—Ç–∞—Ä—Ç —Å –Ω—É–ª—è.")
    except Exception as e:
        log.exception(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö: {e}")

# === –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –∑–∞–ø—Ä–æ—Å –∫ Telegram (—Å –ø–æ–≤—Ç–æ—Ä–æ–º –ø—Ä–∏ —Å–±–æ–µ) ===
async def safe_telegram_call(func, *args, retries=3, **kwargs):
    for attempt in range(1, retries + 1):
        try:
            return await func(*args, **kwargs)
        except exceptions.TelegramAPIError as e:
            if attempt == retries:
                log.error(f"TelegramAPIError (–ø–æ—Å–ª–µ {attempt} –ø–æ–ø—ã—Ç–æ–∫): {e}")
                return None
            await asyncio.sleep(2 * attempt)
        except Exception as e:
            log.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ Telegram: {e}")
            if attempt == retries:
                return None
            await asyncio.sleep(2 * attempt)

# === –°–±—Ä–æ—Å –∞–ø–¥–µ–π—Ç–æ–≤ ===
async def reset_updates():
    try:
        await safe_telegram_call(bot.get_updates, offset=-1)
        log.info("‚úÖ –û—á–∏—Å—Ç–∫–∞ –∞–ø–¥–µ–π—Ç–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.")
    except Exception as e:
        log.warning(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –∞–ø–¥–µ–π—Ç–æ–≤: {e}")

# === –°–æ–∑–¥–∞–Ω–∏–µ –æ–ø—Ä–æ—Å–∞ ===
async def start_poll(poll: dict, from_admin=False):
    try:
        msg = await safe_telegram_call(bot.send_poll,
            chat_id=CHAT_ID,
            question=poll["question"],
            options=poll["options"],
            is_anonymous=False,
            allows_multiple_answers=False
        )
        if not msg:
            log.error("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –æ–ø—Ä–æ—Å.")
            return
        poll_id = msg.poll.id
        active_polls[poll_id] = {
            "message_id": msg.message_id,
            "poll": poll,
            "votes": {},
            "active": True
        }
        await save_data()
        await safe_telegram_call(bot.pin_chat_message, chat_id=CHAT_ID, message_id=msg.message_id, disable_notification=True)
        await safe_telegram_call(bot.send_message, CHAT_ID, "üì¢ <b>–ù–æ–≤—ã–π –æ–ø—Ä–æ—Å!</b>\n–ü—Ä–æ–≥–æ–ª–æ—Å—É–π—Ç–µ, —á—Ç–æ–±—ã –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å —É—á–∞—Å—Ç–∏–µ üëá")
        if from_admin:
            await safe_telegram_call(bot.send_message, ADMIN_ID, f"‚úÖ –û–ø—Ä–æ—Å –∑–∞–ø—É—â–µ–Ω –≤—Ä—É—á–Ω—É—é: {poll['question']}")
        log.info(f"üó≥ –û–ø—Ä–æ—Å –∑–∞–ø—É—â–µ–Ω: {poll['question']}")
    except Exception as e:
        log.exception(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –æ–ø—Ä–æ—Å–∞: {e}")

# === –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –æ–ø—Ä–æ—Å–æ–≤ ===
async def restore_active_polls():
    if not active_polls:
        return
    cleaned = []
    for poll_id, data in list(active_polls.items()):
        try:
            msg_id = data.get("message_id")
            try:
                await safe_telegram_call(bot.edit_message_reply_markup, chat_id=CHAT_ID, message_id=msg_id, reply_markup=None)
            except exceptions.BadRequest:
                del active_polls[poll_id]
                cleaned.append(poll_id)
        except Exception as e:
            log.warning(f"–û—à–∏–±–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è {poll_id}: {e}")
            del active_polls[poll_id]
            cleaned.append(poll_id)
    if cleaned:
        log.info(f"üóë –£–¥–∞–ª–µ–Ω—ã —É—Å—Ç–∞—Ä–µ–≤—à–∏–µ –æ–ø—Ä–æ—Å—ã: {cleaned}")
        await save_data()

# === –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è ===
async def remind_if_needed():
    now = datetime.now(kaliningrad_tz)
    if not (dtime(9, 0) <= now.time() <= dtime(19, 0)):
        return
    weekday = now.strftime("%a").lower()
    if weekday not in ["tue", "thu"]:
        return
    for data in active_polls.values():
        if not data.get("active"):
            continue
        yes_count = sum(1 for v in data["votes"].values() if v["answer"] == "–î–∞ ‚úÖ")
        if yes_count < 10:
            await safe_telegram_call(bot.send_message,
                CHAT_ID,
                f"‚è∞ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ: –ø–æ–∫–∞ —Ç–æ–ª—å–∫–æ {yes_count} —á–µ–ª–æ–≤–µ–∫(–∞) –æ—Ç–≤–µ—Ç–∏–ª–∏ '–î–∞ ‚úÖ'. –ù–µ –∑–∞–±—É–¥—å—Ç–µ –ø—Ä–æ–≥–æ–ª–æ—Å–æ–≤–∞—Ç—å!"
            )
            log.info(f"üîî –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ ({yes_count} '–î–∞')")

# === –ò—Ç–æ–≥–∏ ===
async def send_summary(poll):
    for poll_id, data in list(active_polls.items()):
        if data["poll"] == poll:
            data["active"] = False
            votes = data.get("votes", {})
            yes_users = [v["name"] for v in votes.values() if v["answer"] == "–î–∞ ‚úÖ"]
            no_users = [v["name"] for v in votes.values() if v["answer"] == "–ù–µ—Ç ‚ùå"]
            total_yes = len(yes_users)
            poll_day = poll.get("day")
            if poll_day == "fri":
                status = "üìä –ò—Ç–æ–≥ —Å—É–±–±–æ—Ç–Ω–µ–≥–æ –æ–ø—Ä–æ—Å–∞:"
            else:
                status = (
                    "‚ö†Ô∏è –°–µ–≥–æ–¥–Ω—è –Ω–µ —Å–æ–±–∏—Ä–∞–µ–º—Å—è ‚Äî –º–µ–Ω—å—à–µ 10 —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤."
                    if total_yes < 10 else
                    "‚úÖ –°–µ–≥–æ–¥–Ω—è —Å–æ–±–∏—Ä–∞–µ–º—Å—è –Ω–∞ –ø–µ—Å—á–∞–Ω–∫–µ! ‚öΩ"
                )
            text = (
                f"<b>{poll['question']}</b>\n\n"
                f"‚úÖ –î–∞ ({len(yes_users)}): {', '.join(yes_users) or '‚Äî'}\n"
                f"‚ùå –ù–µ—Ç ({len(no_users)}): {', '.join(no_users) or '‚Äî'}\n\n"
                f"{status}\n\n<i>–í—Å–µ–≥–æ –ø—Ä–æ–≥–æ–ª–æ—Å–æ–≤–∞–ª–æ: {len(votes)}</i>"
            )
            await safe_telegram_call(bot.send_message, CHAT_ID, text)
            for v in votes.values():
                if v["answer"] == "–î–∞ ‚úÖ":
                    stats[v["name"]] = stats.get(v["name"], 0) + 1
            del active_polls[poll_id]
            await save_data()
            log.info(f"üìà –ò—Ç–æ–≥–∏ –æ–ø—Ä–æ—Å–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã: {poll['question']}")
            break

# === –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–≤–µ—Ç–æ–≤ ===
@dp.poll_answer_handler()
async def handle_poll_answer(poll_answer: types.PollAnswer):
    uid = poll_answer.user.id
    uname = poll_answer.user.first_name or poll_answer.user.username or str(uid)
    option_ids = poll_answer.option_ids
    for poll_id, data in active_polls.items():
        if poll_answer.poll_id == poll_id:
            if not option_ids:
                data["votes"].pop(str(uid), None)
            else:
                answer = data["poll"]["options"][option_ids[0]]
                data["votes"][str(uid)] = {"name": uname, "answer": answer}
            await save_data()
            return

# === –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ ===
def schedule_polls():
    scheduler.remove_all_jobs()
    loop = asyncio.get_event_loop()
    for poll in polls_config:
        tp = list(map(int, poll["time_poll"].split(":")))
        tg = list(map(int, poll["time_game"].split(":")))
        scheduler.add_job(
            lambda p=poll: asyncio.run_coroutine_threadsafe(start_poll(p), loop),
            trigger=CronTrigger(day_of_week=poll["day"], hour=tp[0], minute=tp[1]),
            id=f"poll_{poll['day']}", replace_existing=True
        )
        next_day = "sat" if poll["day"] == "fri" else poll["day"]
        scheduler.add_job(
            lambda p=poll: asyncio.run_coroutine_threadsafe(send_summary(p), loop),
            trigger=CronTrigger(day_of_week=next_day, hour=max(tg[0] - 1, 0), minute=tg[1]),
            id=f"summary_{poll['day']}", replace_existing=True
        )
    scheduler.add_job(lambda: asyncio.run_coroutine_threadsafe(remind_if_needed(), loop),
                      "interval", hours=2, id="reminder", replace_existing=True)
    scheduler.add_job(lambda: asyncio.run_coroutine_threadsafe(save_data(), loop),
                      "interval", minutes=5, id="autosave", replace_existing=True)
    log.info("‚úÖ –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –æ–±–Ω–æ–≤–ª—ë–Ω (Europe/Kaliningrad)")

# === Keep-alive ===
async def handle(request):
    return web.Response(text="‚úÖ Bot is alive and running!")

async def start_keepalive_server():
    app = web.Application()
    app.router.add_get("/", handle)
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, "0.0.0.0", PORT)
    await site.start()
    log.info("üåê KeepAlive server started.")

# === –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ ===
async def shutdown():
    log.info("üõë –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã...")
    try:
        await save_data()
    except Exception:
        pass
    try:
        scheduler.shutdown(wait=False)
    except Exception:
        pass
    try:
        await bot.close()
    except Exception:
        pass
    log.info("‚úÖ –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏ –¥–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã.")

# === –û—Å–Ω–æ–≤–Ω–æ–π –∑–∞–ø—É—Å–∫ ===
async def main():
    await load_data()
    try:
        await bot.delete_webhook(drop_pending_updates=True)
        log.info("üîÅ Webhook —É–¥–∞–ª—ë–Ω, polling –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω.")
    except Exception as e:
        log.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å webhook: {e}")
    try:
        await reset_updates()
    except Exception as e:
        log.warning(f"–û—à–∏–±–∫–∞ reset_updates: {e}")
    schedule_polls()
    scheduler.start()
    await restore_active_polls()
    await start_keepalive_server()
    log.info(f"üöÄ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω {datetime.now(kaliningrad_tz):%Y-%m-%d %H:%M:%S %Z}")
    try:
        await bot.send_message(ADMIN_ID, "‚úÖ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!")
    except Exception:
        pass
    loop = asyncio.get_event_loop()
    for sig in (signal.SIGINT, signal.SIGTERM):
        try:
            loop.add_signal_handler(sig, lambda s=sig: asyncio.create_task(shutdown()))
        except NotImplementedError:
            pass
    await dp.start_polling()

if __name__ == "__main__":
    asyncio.run(main())



